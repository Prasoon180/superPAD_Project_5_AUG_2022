//SPDX-License-Identifier:GPL-3.0
pragma solidity >= 0.8.15;
import "@openzeppelin/contracts/access/Ownable.sol";
contract BEP20 is Ownable  {

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
  
    uint8 public decimal = 18;         
    uint256 public totalSupply;
    uint256 initialSupply = 15140000;
    string public name;
    string public symbol;

    /**
     * @dev Returns the name of the token.
     */

      /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */

     /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IBEP20-balanceOf} and {IBEP20-transfer}.
     */



     string tokenName = "superPAD";
     string tokenSymbol = "SPAD";
    
     mapping(address => uint256) public balanceOf;
     mapping(address => mapping(address=>uint256)) public allowance;

     event Transfer(address indexed from, address indexed to, uint256 value);
     event Approval(address indexed _owner, address indexed _spender, uint256 value);
     event Burn(address indexed from, uint256 value);
   

    constructor()  {
    totalSupply = initialSupply*10**uint256(decimal);
    balanceOf[msg.sender] = totalSupply;
    name = tokenName;
    symbol = tokenSymbol;
     
    }

    function allowances(address owner, address spender) public view  returns (uint256) {
        require( owner == msg.sender);
        return allowance[owner][spender];
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IBEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */

     function increaseAllowances(address _spender, uint256 addedValue) public
       returns (bool) {
      require(_spender != (0x0000000000000000000000000000000000000000));
      allowance[msg.sender][_spender];
      uint256 currentAllowance = allowance[msg.sender][_spender];
      approve(_spender, currentAllowance + addedValue);
      return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */

     function decreaseAllowances(address _spender, uint256 subtractedValue) public 
      returns (bool) {
        uint256 currentAllowance = allowance[msg.sender][_spender];
        require(currentAllowance >= subtractedValue, "BEP20: decreased allowance below zero");
        approve(_spender,currentAllowance - subtractedValue);

        return true;
    }

    

    function _transfer(address _from, address _to, uint256 _value) internal {
    require(_to != 0x0000000000000000000000000000000000000000, " Transfer to zero address");
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);

    uint previousBalances = balanceOf[_from] + balanceOf[_to];

    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    function transfer(address _to, uint256 _value) external  returns(bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the BIP. See the note at the beginning of {BEP20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */

    function transferFrom(address _from, address  _to, uint256 _value) public 
    returns(bool success){
    require(_from != (0x0000000000000000000000000000000000000000));
    require(_to != (0x0000000000000000000000000000000000000000));

     require(_value <= allowance[_from][msg.sender]);
     allowance[_from][msg.sender] -= _value;
     _transfer(_from, _to, _value);
     return true;
    }

    
    /**
     * @dev See {IBEP20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */

    function approve(address _spender, uint256 _value) public 
    returns(bool success) {
         require(_spender != (0x0000000000000000000000000000000000000000));
         allowance[msg.sender][_spender] = _value;
         emit Approval(msg.sender, _spender, _value);
         return true;
    }
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] > _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) external returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;

        emit Burn(_from, _value);
        return true;
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */

    function mint(address to, uint256 _value) external onlyOwner  returns (bool success) {
       // require(to != address(this));
        require(to == msg.sender);
        balanceOf[msg.sender] += _value;
        totalSupply += _value;
        return true;
    }

    /**
    *@dev saveApprove to fix the approve race condition
    @param _spender The address which will spend the funds.
    @param _currentValue The actual amount of tokens that the _spender can spend.
    @param _value The amount of tokens to be spent.
    *
    *This is not a simple and most important, a backwards compatible way to fix
    *The race condition issue on the approve function.There is large and unfinished
    *discussion on the community https://github.com/ethereum/EIP/issues/738
    *about this issue and the "best" approach is add a safeApprove function to
    *validate the amount/value and leave the approve function as is to comply with
    *the BEP20 standard
    *
    */

    function safeApprove(address _spender, uint256 _currentValue, uint256 _value) external  
     returns
    (bool success) {
        if (allowance[msg.sender][_spender] == _currentValue){
            return approve(_spender, _value);
        }
        return false;
    }


}
